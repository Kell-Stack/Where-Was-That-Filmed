{"ast":null,"code":"// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.3\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n */\n\n/**\n * @license\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n\n  this.markers_ = [];\n  /**\n   *  @type {Array.<Cluster>}\n   */\n\n  this.clusters_ = [];\n  this.sizes = [53, 56, 66, 78, 90];\n  /**\n   * @private\n   */\n\n  this.styles_ = [];\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.ready_ = false;\n  var options = opt_options || {};\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.gridSize_ = options['gridSize'] || 60;\n  /**\n   * @private\n   */\n\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.maxZoom_ = options['maxZoom'] || null;\n  this.styles_ = options['styles'] || [];\n  /**\n   * @type {string}\n   * @private\n   */\n\n  this.imagePath_ = options['imagePath'] || this.MARKER_CLUSTER_IMAGE_PATH_;\n  /**\n   * @type {string}\n   * @private\n   */\n\n  this.imageExtension_ = options['imageExtension'] || this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n  this.setMap(map);\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.prevZoom_ = this.map_.getZoom(); // Add the map event listeners\n\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function () {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(that.map_.maxZoom || 100, that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);\n    zoom = Math.min(Math.max(zoom, minZoom), maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n  google.maps.event.addListener(this.map_, 'idle', function () {\n    that.redraw();\n  }); // Finally, add the markers\n\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\n\n\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\n\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\n\nMarkerClusterer.prototype.extend = function (obj1, obj2) {\n  return function (object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n\n    return this;\n  }.apply(obj1, [obj2]);\n};\n/**\n * Implementaion of the interface method.\n * @ignore\n */\n\n\nMarkerClusterer.prototype.onAdd = function () {\n  this.setReady_(true);\n};\n/**\n * Implementaion of the interface method.\n * @ignore\n */\n\n\nMarkerClusterer.prototype.draw = function () {};\n/**\n * Sets up the styles object.\n *\n * @private\n */\n\n\nMarkerClusterer.prototype.setupStyles_ = function () {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\n\n\nMarkerClusterer.prototype.fitMapToMarkers = function () {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\n\n\nMarkerClusterer.prototype.setStyles = function (styles) {\n  this.styles_ = styles;\n};\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\n\n\nMarkerClusterer.prototype.getStyles = function () {\n  return this.styles_;\n};\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\n\n\nMarkerClusterer.prototype.isZoomOnClick = function () {\n  return this.zoomOnClick_;\n};\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\n\n\nMarkerClusterer.prototype.isAverageCenter = function () {\n  return this.averageCenter_;\n};\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\n\n\nMarkerClusterer.prototype.getMarkers = function () {\n  return this.markers_;\n};\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\n\n\nMarkerClusterer.prototype.getTotalMarkers = function () {\n  return this.markers_.length;\n};\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\n\n\nMarkerClusterer.prototype.setMaxZoom = function (maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\n\n\nMarkerClusterer.prototype.getMaxZoom = function () {\n  return this.maxZoom_;\n};\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\n\n\nMarkerClusterer.prototype.calculator_ = function (markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\n\n\nMarkerClusterer.prototype.setCalculator = function (calculator) {\n  this.calculator_ = calculator;\n};\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\n\n\nMarkerClusterer.prototype.getCalculator = function () {\n  return this.calculator_;\n};\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\n\n\nMarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; marker = markers[i]; i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\n\n\nMarkerClusterer.prototype.pushMarkerTo_ = function (marker) {\n  marker.isAdded = false;\n\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function () {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n\n  this.markers_.push(marker);\n};\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\n\n\nMarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\n\n\nMarkerClusterer.prototype.removeMarker_ = function (marker) {\n  var index = -1;\n\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n  this.markers_.splice(index, 1);\n  return true;\n};\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\n\n\nMarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n    return false;\n  }\n};\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\n\n\nMarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; marker = markersCopy[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\n\n\nMarkerClusterer.prototype.setReady_ = function (ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\n\n\nMarkerClusterer.prototype.getTotalClusters = function () {\n  return this.clusters_.length;\n};\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\n\n\nMarkerClusterer.prototype.getMap = function () {\n  return this.map_;\n};\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\n\n\nMarkerClusterer.prototype.setMap = function (map) {\n  this.map_ = map;\n};\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\n\n\nMarkerClusterer.prototype.getGridSize = function () {\n  return this.gridSize_;\n};\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\n\n\nMarkerClusterer.prototype.setGridSize = function (size) {\n  this.gridSize_ = size;\n};\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\n\n\nMarkerClusterer.prototype.getMinClusterSize = function () {\n  return this.minClusterSize_;\n};\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\n\n\nMarkerClusterer.prototype.setMinClusterSize = function (size) {\n  this.minClusterSize_ = size;\n};\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\n\n\nMarkerClusterer.prototype.getExtendedBounds = function (bounds) {\n  var projection = this.getProjection(); // Turn the bounds into latlng.\n\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()); // Convert the points to pixels and the extend out by the grid size.\n\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_; // Convert the pixel points back to LatLng\n\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix); // Extend the bounds to contain the new bounds.\n\n  bounds.extend(ne);\n  bounds.extend(sw);\n  return bounds;\n};\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\n\n\nMarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n/**\n * Clears all clusters and markers from the clusterer.\n */\n\n\nMarkerClusterer.prototype.clearMarkers = function () {\n  this.resetViewport(true); // Set the markers a empty array.\n\n  this.markers_ = [];\n};\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\n\n\nMarkerClusterer.prototype.resetViewport = function (opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  } // Reset the markers to not be added and to be invisible.\n\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n/**\n *\n */\n\n\nMarkerClusterer.prototype.repaint = function () {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw(); // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n\n  window.setTimeout(function () {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n/**\n * Redraws the clusters.\n */\n\n\nMarkerClusterer.prototype.redraw = function () {\n  this.createClusters_();\n};\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\n\n\nMarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\n\n\nMarkerClusterer.prototype.addToClosestCluster_ = function (marker) {\n  var distance = 40000; // Some large number\n\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n/**\n * Creates the clusters.\n *\n * @private\n */\n\n\nMarkerClusterer.prototype.createClusters_ = function () {\n  if (!this.ready_) {\n    return;\n  } // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n\n\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(), this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\n\n\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(), markerClusterer.getGridSize());\n}\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\n\n\nCluster.prototype.isMarkerAlreadyAdded = function (marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\n\n\nCluster.prototype.addMarker = function (marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n  var len = this.markers_.length;\n\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\n\n\nCluster.prototype.getMarkerClusterer = function () {\n  return this.markerClusterer_;\n};\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\n\n\nCluster.prototype.getBounds = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  return bounds;\n};\n/**\n * Removes the cluster\n */\n\n\nCluster.prototype.remove = function () {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\n\n\nCluster.prototype.getSize = function () {\n  return this.markers_.length;\n};\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\n\n\nCluster.prototype.getMarkers = function () {\n  return this.markers_;\n};\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\n\n\nCluster.prototype.getCenter = function () {\n  return this.center_;\n};\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\n\n\nCluster.prototype.calculateBounds_ = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\n\n\nCluster.prototype.isMarkerInClusterBounds = function (marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\n\n\nCluster.prototype.getMap = function () {\n  return this.map_;\n};\n/**\n * Updates the cluster icon\n */\n\n\nCluster.prototype.updateIcon = function () {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\n\n\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n  this.setMap(this.map_);\n}\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\n\n\nClusterIcon.prototype.triggerClusterClick = function () {\n  var markerClusterer = this.cluster_.getMarkerClusterer(); // Trigger the clusterclick event.\n\n  google.maps.event.trigger(markerClusterer.map_, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\n\n\nClusterIcon.prototype.onAdd = function () {\n  this.div_ = document.createElement('DIV');\n\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function () {\n    that.triggerClusterClick();\n  });\n};\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\n\n\nClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n/**\n * Draw the icon.\n * @ignore\n */\n\n\nClusterIcon.prototype.draw = function () {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n    this.div_.style.zIndex = google.maps.Marker.MAX_ZINDEX + 1;\n  }\n};\n/**\n * Hide the icon.\n */\n\n\nClusterIcon.prototype.hide = function () {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n\n  this.visible_ = false;\n};\n/**\n * Position and show the icon.\n */\n\n\nClusterIcon.prototype.show = function () {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n\n  this.visible_ = true;\n};\n/**\n * Remove the icon from the map\n */\n\n\nClusterIcon.prototype.remove = function () {\n  this.setMap(null);\n};\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\n\n\nClusterIcon.prototype.onRemove = function () {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\n\n\nClusterIcon.prototype.setSums = function (sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n/**\n * Sets the icon to the the styles.\n */\n\n\nClusterIcon.prototype.useStyle = function () {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\n\n\nClusterIcon.prototype.setCenter = function (center) {\n  this.center_ = center;\n};\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\n\n\nClusterIcon.prototype.createCss = function (pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 && this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) + 'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px;');\n    }\n\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 && this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) + 'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' + pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' + txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n}; // Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\n\n\nvar window = window || {};\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] = MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] = MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] = MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] = MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] = MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] = MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] = MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] = MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] = MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] = MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] = MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] = MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] = MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] = MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys = Object.keys || function (o) {\n  var result = [];\n\n  for (var name in o) {\n    if (o.hasOwnProperty(name)) result.push(name);\n  }\n\n  return result;\n};\n\nif (typeof module == 'object') {\n  module.exports = MarkerClusterer;\n}","map":{"version":3,"sources":["/Users/tpl9/Dev/WWTF/client/src/markerclusterer/markerclusterer.js"],"names":["MarkerClusterer","map","opt_markers","opt_options","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","minZoom","maxZoom","Math","min","mapTypes","getMapTypeId","max","resetViewport","redraw","length","Object","keys","addMarkers","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","i","size","push","url","height","width","fitMapToMarkers","markers","getMarkers","bounds","LatLngBounds","marker","getPosition","fitBounds","setStyles","styles","getStyles","isZoomOnClick","isAverageCenter","getTotalMarkers","setMaxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","markersCopy","slice","r","ready","createClusters_","getTotalClusters","getMap","getGridSize","setGridSize","getMinClusterSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","cluster","remove","oldClusters","window","setTimeout","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","d","addToClosestCluster_","distance","clusterToAddTo","pos","center","getCenter","isMarkerInClusterBounds","Cluster","mapBounds","getBounds","markerClusterer","markerClusterer_","center_","bounds_","clusterIcon_","ClusterIcon","isMarkerAlreadyAdded","calculateBounds_","l","len","updateIcon","getMarkerClusterer","getSize","mz","hide","sums","setCenter","setSums","show","opt_padding","padding_","cluster_","div_","sums_","visible_","triggerClusterClick","trigger","document","createElement","getPosFromLatLng_","style","cssText","createCss","innerHTML","panes","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","zIndex","Marker","MAX_ZINDEX","display","onRemove","parentNode","removeChild","text_","index_","useStyle","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join","o","result","name","hasOwnProperty","module","exports"],"mappings":"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","sourcesContent":["// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.3\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n */\n\n/**\n * @license\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(that.map_.maxZoom || 100,\n                         that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);\n    zoom = Math.min(Math.max(zoom,minZoom),maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; marker = markers[i]; i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; marker = markersCopy[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer.map_, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n    this.div_.style.zIndex = google.maps.Marker.MAX_ZINDEX + 1;\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nvar window = window || {};\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys = Object.keys || function(o) {\n    var result = [];\n    for(var name in o) {\n        if (o.hasOwnProperty(name))\n          result.push(name);\n    }\n    return result;\n};\n\nif (typeof module == 'object') {\n  module.exports = MarkerClusterer;\n}"]},"metadata":{},"sourceType":"module"}